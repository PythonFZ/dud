[{"id":0,"href":"/dud/dev/install/","title":"Install","section":"","content":" Installing Dud # System Requirements # Dud requires a UNIX-based operating system. Dud does not run on Windows and is only tested on Linux with a 64-bit x86 CPU. That said, Dud should work on Windows Subsystem for Linux and macOS operating systems, as well as 32-bit x86 and ARM CPU architectures. If you want to kick Dud\u0026rsquo;s tires in any of these environments, great! If you encounter a problem, please submit a Github issue. Thanks in advance!\nrclone # Dud uses rclone to interact with remote storage. Rclone is required for the push and fetch commands. Visit https://rclone.org for more information and installation instructions.\nInstalling Dud from a release # Dud releases are published on Github. Select a release that matches your operating system and CPU architecture. Please keep in mind the notes in the System Requirements section above. Builds besides Linux x84_64 are provided for convenience, but they are not explicitly tested.\nFirst download the release tarball, then extract its contents, and finally copy the dud executable to somewhere in your $PATH. The following shell command accomplishes these steps for a given release asset URL, copying the dud executable to the user\u0026rsquo;s default Go binary path, ~/go/bin.\ncurl -fL 'https://github.com/kevin-hanselman/dud/releases/COPY_URL_FROM_GITHUB.tar.gz' \\ | tar -C ~/go/bin -zxvf - dud Building Dud from source # You will need the following software packages:\ngit Go (the version in ./go.mod) GNU Make First, clone the Dud code repository:\ngit clone https://github.com/kevin-hanselman/dud Now use Make to build the Dud executable and install it in your Go binaries directory.\nmake install This command will compile Dud, run an automated test suite, and install Dud to a standard location. It will show you where it installed Dud, and if you have a standard Go environment, it will likely be installed at ~/go/bin/dud. If you haven\u0026rsquo;t already, add this directory to your $PATH environment variable so Dud is accessible from anywhere on your system.\n"},{"id":1,"href":"/dud/dev/getting_started/","title":"Getting Started","section":"","content":" A Tour of Dud # The goal of this page is to walk through the core capabilities of Dud. After creating a Dud project, we\u0026rsquo;ll store and version a large archive file. Then we\u0026rsquo;ll create a reproducible data pipeline to extract files from the archive. Finally, we\u0026rsquo;ll push our data and code to remote locations to share our work with others. If you want to follow along, install Dud before getting started. If you want to complete the last section of this walkthrough, be sure to install rclone as well.\nCreating a Dud project # First, let\u0026rsquo;s create a new Dud project:\n$ mkdir ~/cifar \u0026amp;\u0026amp; cd ~/cifar $ dud init Dud project initialized. See .dud/config.yaml and .dud/rclone.conf to customize the project. As Dud tells us, dud init creates a .dud directory and some config files. Dud is designed to be ready to use out of the box, so don\u0026rsquo;t worry about these files for now; we\u0026rsquo;ll revisit them towards the end of this walkthrough.\nNext, let\u0026rsquo;s download the CIFAR-10 computer vision dataset.\n$ curl -sSO 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz' $ du -h cifar-10-python.tar.gz 163M\tcifar-10-python.tar.gz Storing and versioning large files # Now we have a tarball of the dataset. This file is fairly large, so it\u0026rsquo;s not a good idea to store it in Git. Dud, however, is purpose-built for large files. (In fact, this file is quite small for Dud; it can comfortably handle files in the hundreds of Gigabytes.)\nTo have Dud store and version this file, we need to create a stage. In Dud, a stage is basically a record of one or more files (or directories) that Dud should track. Stages are written in YAML, and Dud provides a command-line interface to help you with the stage syntax. Here\u0026rsquo;s the command to create the stage file for our dataset tarball:\n$ dud stage gen -o cifar-10-python.tar.gz | tee cifar.yaml working-dir: . outputs: cifar-10-python.tar.gz: {} dud stage gen -o cifar-10-python.tar.gz tells Dud: \u0026ldquo;Generate the stage YAML to track the file cifar-10-python.tar.gz, and print the YAML to standard output.\u0026rdquo; Because dud stage gen prints to stdout, in true UNIX fashion we can redirect its output anywhere we like. In this example, I use tee to copy the YAML to cifar.yaml while keeping stdout intact. This is just so we can quickly see the contents of the file in this walkthrough. I could\u0026rsquo;ve just as easily used \u0026gt; cifar.yaml.\nNow we have a stage file, but we need to register it with Dud. We do that with dud stage add:\n$ dud stage add cifar.yaml Added cifar.yaml to the index. dud stage add adds a stage to Dud\u0026rsquo;s index. The index is a simple text file (located at .dud/index) that tells Dud where all the stages are defined in the project. Don\u0026rsquo;t worry too much about the index for now. It\u0026rsquo;s enough to know that the index makes commands like dud status find and load our stage files:\n$ dud status cifar.yaml stage definition not checksummed cifar-10-python.tar.gz not committed dud status gives us an overview of the Dud project. Here we can see our new stage, cifar.yaml, and the file it tracks, cifar-10-python.tar.gz. Dud tells us that the tarball is \u0026ldquo;uncommitted.\u0026rdquo; This means Dud isn\u0026rsquo;t storing this version of the file yet. Let\u0026rsquo;s fix that by committing the stage:\n$ dud commit committing stage cifar.yaml cifar-10-python.tar.gz 162.60 MiB / 162.60 MiB 100% ?/s 65ms total dud commit goes through all of our stages (in this case, just cifar.yaml) and copies their files/directories to the Dud cache. The cache is a directory that holds all versions of all files and directories owned by Dud. By default, the cache lives at .dud/cache/, but it\u0026rsquo;s location is configurable (see .dud/config.yaml).\nTo get a better sense of what dud commit did, let\u0026rsquo;s look at the directory structure of the project:\n$ tree -an . ├── .dud │ ├── .gitignore │ ├── cache │ │ └── fe │ │ └── 3d11c475ae0f6fec91f3cf42f9c69e87dc32ec6b44a83f8b22544666e25eea │ ├── config.yaml │ ├── index │ └── rclone.conf ├── cifar-10-python.tar.gz -\u0026gt; .dud/cache/fe/3d11c475ae0f6fec91f3cf42f9c69e87dc32ec6b44a83f8b22544666e25eea └── cifar.yaml 3 directories, 7 files Our tarball has been replaced with a link to a file in Dud\u0026rsquo;s cache. That cached file is our original tarball, but it\u0026rsquo;s named after the checksum of its contents. This is called content-addressed storage, and it allows Dud to track any number of files (and any number of versions of files) with reasonable assurances against conflicts or duplication.\nBut how do we make sure we don\u0026rsquo;t corrupt the cached version of the tarball? What happens if we accidentally modify our dataset?\n$ echo 'accidental overwrite' \u0026gt; cifar-10-python.tar.gz /usr/bin/sh: 1: cannot create cifar-10-python.tar.gz: Permission denied Dud makes it difficult to accidentally modify committed files. When Dud commits a file, it makes the link to the cache read-only.\nThe tarball isn\u0026rsquo;t the only thing that\u0026rsquo;s changed. Let\u0026rsquo;s look at our stage file:\n$ cat cifar.yaml checksum: 801b84d7215b34f14d04db1750edf0ede4686b606b8028bdda63f681bf62d324 working-dir: . outputs: cifar-10-python.tar.gz: checksum: fe3d11c475ae0f6fec91f3cf42f9c69e87dc32ec6b44a83f8b22544666e25eea Dud recorded the tarball\u0026rsquo;s checksum in the stage file. (It also checksummed the stage file itself; more on that later.) With a copy of this stage file and the Dud cache, we can easily get this specific version of the tarball back. Let\u0026rsquo;s see how that works by deleting the link to the tarball and asking Dud to checkout our stage:\n$ rm cifar-10-python.tar.gz $ readlink -v cifar-10-python.tar.gz readlink: cifar-10-python.tar.gz: No such file or directory $ dud checkout checking out stage cifar.yaml cifar-10-python.tar.gz 1 / 1 100% ?/s 0s total $ readlink -v cifar-10-python.tar.gz .dud/cache/fe/3d11c475ae0f6fec91f3cf42f9c69e87dc32ec6b44a83f8b22544666e25eea dud checkout goes through all of our stages, finds their checksummed files in the cache, and makes the appropriate links in our workspace.\nBefore we move on, let\u0026rsquo;s check dud status again:\n$ dud status cifar.yaml stage definition up-to-date cifar-10-python.tar.gz up-to-date (link) Dud tells us that cifar-10-python.tar.gz is committed and up-to-date, and it\u0026rsquo;s available in our working directory as a read-only link to the cache.\nWe also see that cifar.yaml has its \u0026ldquo;stage definition up-to-date.\u0026rdquo; Don\u0026rsquo;t worry about this for this walkthrough. But if you\u0026rsquo;re curious, this is what the top-level checksum in cifar.yaml buys us: Dud can detect when we\u0026rsquo;ve changed the stage (for example, added another file to track) to better inform its actions.\nCreating a data pipeline # Okay, let\u0026rsquo;s extract the tarball already! We do that with tar, but it turns out tar is hard to use. We could write a quick shell script so we don\u0026rsquo;t have to remember the tar flags, but we can do one better with Dud.\nNow we\u0026rsquo;ll glimpse the full power of Dud stages. As we\u0026rsquo;ve seen already, Dud stages own files, but they can also own the command that generates those files. On top of that, stages can depend on other stages. Let\u0026rsquo;s see this in action by creating a stage to extract the CIFAR-10 tarball:\n$ mkdir cifar-10-batches-py $ dud stage gen \\ -i cifar-10-python.tar.gz \\ -o cifar-10-batches-py/ \\ -- tar -xvf cifar-10-python.tar.gz \\ | tee extract_cifar.yaml command: tar -xvf cifar-10-python.tar.gz working-dir: . inputs: cifar-10-python.tar.gz: {} outputs: cifar-10-batches-py: is-dir: true There\u0026rsquo;s only two lines in this dud stage gen command that are new to us. -i cifar-10-python.tar.gz declares the tarball as an input to this stage. If the tarball changes (for example, if new images are added), Dud will know this stage should be re-run. The -- tells Dud to stop looking for command-line flags (like -i and -o) and to treat the rest of the arguments as a shell command. In this case, our command is the tar command to extract the contents of the archive.\nIn the YAML output, notice that Dud can own entire directories, not just files. dud stage gen knew to add is-dir: true because we created the directory ahead of time.\nLet\u0026rsquo;s add the stage and check our status:\n$ dud stage add extract_cifar.yaml Added extract_cifar.yaml to the index. $ dud status cifar.yaml stage definition up-to-date cifar-10-python.tar.gz up-to-date (link) extract_cifar.yaml stage definition not checksummed cifar-10-batches-py empty directory This looks as expected. Our tarball is committed, but we haven\u0026rsquo;t extracted it yet. We do that using dud run:\n$ dud run nothing to do for stage cifar.yaml running stage extract_cifar.yaml cifar-10-batches-py/ cifar-10-batches-py/data_batch_4 cifar-10-batches-py/readme.html cifar-10-batches-py/test_batch cifar-10-batches-py/data_batch_3 cifar-10-batches-py/batches.meta cifar-10-batches-py/data_batch_2 cifar-10-batches-py/data_batch_5 cifar-10-batches-py/data_batch_1 As we can see, dud run was considering more than just our new stage. It notes that there is \u0026ldquo;nothing to do for stage cifar.yaml\u0026rdquo;. This makes sense because we didn\u0026rsquo;t define a command in that stage. Then, Dud begins running extract_cifar.yaml, and it sends all of tar\u0026rsquo;s output to the terminal.\nNow we can check that the tar command worked:\n$ ls cifar-10-batches-py/ batches.meta data_batch_2 data_batch_4 readme.html data_batch_1 data_batch_3 data_batch_5 test_batch Congrats on defusing the bomb! Now that we know our pipeline worked, let\u0026rsquo;s commit everything:\n$ dud commit committing stage cifar.yaml cifar-10-python.tar.gz up-to-date; skipping commit committing stage extract_cifar.yaml cifar-10-batches-py 177.59 MiB / 177.59 MiB 100% ?/s 30ms total Notice that Dud detected that the tarball from cifar.yaml hasn\u0026rsquo;t changed, so it knew not to waste time committing it again.\nLet\u0026rsquo;s take another look at our project status for good measure:\n$ dud status cifar.yaml stage definition up-to-date cifar-10-python.tar.gz up-to-date (link) extract_cifar.yaml stage definition up-to-date cifar-10-batches-py x8 up-to-date (link) Looks good! Note that because cifar-10-batches-py is a directory, dud status reports the status of the contained files. Here, Dud is telling us that the cifar-10-batches-py directory has eight files, and they are all up-to-date and linked to the Dud cache.\nBecause everything is up-to-date, I bet you can guess what happens if we try re-running our pipeline:\n$ dud run nothing to do for stage cifar.yaml nothing to do for stage extract_cifar.yaml Because both of our stages are committed and up-to-date, Dud detects that there\u0026rsquo;s no sense in re-extracting the tarball. Excellent!\nLet\u0026rsquo;s finish up by visualizing our data pipeline. Dud can output its pipelines in DOT format to be visualized with Graphviz. If we have Graphviz installed, we can pipe dud graph directly into dot to generate an image of the pipeline:\n$ dud graph | dot -Tpng -o pipeline.png Dud shows our two stages as boxes with the files/directories they own as encapsulated ellipses. The arrow between stages shows that the extract_cifar.yaml stage depends on the tarball file owned by the cifar.yaml stage.\nSharing our work # Now that we have the humble beginnings of our data pipeline working, it\u0026rsquo;s a good time to upload our work to a shared location so other people can access and/or collaborate on our code and data. Currently our \u0026ldquo;code\u0026rdquo; is our data pipeline definition \u0026ndash; the Dud stage files we wrote in the steps above \u0026ndash; and miscellaneous configuration files. Our data is the binary files that we\u0026rsquo;ve committed to Dud\u0026rsquo;s cache \u0026ndash; the CIFAR tarball and its extracted contents. Let\u0026rsquo;s tackle uploading our data first.\nSharing our data with Dud and Rclone # Dud uses rclone to synchronize the local Dud cache (.dud/cache) with a remote location. Rclone supports an impressive number of storage systems/providers, but for this demo we\u0026rsquo;ll use a \u0026ldquo;fake\u0026rdquo; remote cache \u0026ndash; another local directory on our computer. However, the following steps apply to any \u0026ldquo;real\u0026rdquo; remote. (If you\u0026rsquo;re following along and haven\u0026rsquo;t installed rclone yet, now\u0026rsquo;s the time. Check the rclone website for instructions.)\nRecall that when we ran dud init, Dud told us that it created two config files: .dud/config.yaml and .dud/rclone.conf. Let\u0026rsquo;s peek at these files now, starting with .dud/rclone.conf:\n$ cat .dud/rclone.conf # rclone config file # Run 'rclone --config .dud/rclone.conf config' to setup a remote Dud cache, # and then set the 'remote' value in .dud/config.yaml to a valid rclone remote # path. # See: https://rclone.org/docs/#syntax-of-remote-paths .dud/rclone.conf is an rclone configuration file dedicated to the project. In it, we will tell rclone where to send and receive our data files. It\u0026rsquo;s currently empty, but Dud gives us pointers on how to proceed with setting up a remote cache.\nrclone config starts an interactive command-line interface to configure a remote location step-by-step, and the --config .dud/rclone.conf flag tells rclone where to store the resulting configuration. Most of the time, you\u0026rsquo;ll want to use this command to configure a remote with rclone. In our case, we\u0026rsquo;ll cut to the chase. Add the following two lines to the config file:\n# .dud/rclone.conf [fake_remote] type = local This config file will tell rclone that we have a remote location called fake_remote that\u0026rsquo;s actually just the local filesystem. Again, in a real scenario you\u0026rsquo;ll want to follow the rclone config command to configure a true remote cache that collaborators can access. The important outcome is that we can now tell Dud the name of the rclone remote we created (fake_remote) and it will coordinate with rclone to handle the rest \u0026ndash; regardless of the location and underlying implementation of the \u0026ldquo;remote\u0026rdquo; itself.\nTo tell Dud about our new \u0026ldquo;remote\u0026rdquo;, we\u0026rsquo;ll edit Dud\u0026rsquo;s configuration file, .dud/config.yaml. Before we do that, let\u0026rsquo;s examine the file:\n$ cat .dud/config.yaml # Dud project-level config file # This config file overrides any user configuration from # \u0026quot;$XDG_CONFIG_HOME/dud/config.yaml\u0026quot; or \u0026quot;~/.config/dud/config.yaml\u0026quot;. # This is the default cache location. Uncomment here or add to your user-level # config to override. # cache: .dud/cache # To enable push and fetch, set 'remote' to a valid rclone remote path. For # example, if you have a remote called \u0026quot;s3\u0026quot; in your .dud/rclone.conf, and you # want your remote cache to live in a bucket called 'dud', you would write: # # remote: s3:dud # # For more info, see the rclone docs: # https://rclone.org/docs/#syntax-of-remote-paths Dud again gives us some pointers on configuring a remote cache: we need to set the remote value to a path format described in the rclone documentation. We can accomplish this any number of ways, but we\u0026rsquo;ll use the opportunity to explore more of Dud\u0026rsquo;s CLI. dud config allows programmatic access to Dud\u0026rsquo;s config file. Let\u0026rsquo;s use it to set our remote:\n$ dud config set remote fake_remote:/tmp/dud/cache This command sets the remote key in the Dud config to the value fake_remote:/tmp/dud/cache. This value tells Dud and rclone that we\u0026rsquo;re communicating with the remote named fake_remote, and the base directory of our remote cache will be /tmp/dud/cache. (As mentioned in the rclone documentation, including a leading forward slash in the remote path is not recommended in most cases. It\u0026rsquo;s required here because the remote is an absolute path on our local filesystem.)\nWe\u0026rsquo;re now ready to push our data to the remote cache! We do this with one simple command:\n$ dud push pushing stage cifar.yaml Gathering files 1 Transferred: 162.600 MiB / 162.600 MiB, 100%, 0 B/s, ETA - Transferred: 1 / 1, 100% Elapsed time: 0.3s Fixing permissions 1 / 1 pushing stage extract_cifar.yaml Gathering files 9 Transferred: 177.589 MiB / 177.589 MiB, 100%, 0 B/s, ETA - Transferred: 9 / 9, 100% Elapsed time: 0.2s Fixing permissions 9 / 9 dud push goes through all of our stages, looks up their committed artifacts (by checksum), and instructs rclone to copy them to the remote cache. We can confirm our artifacts were copied to /tmp/dud/cache using rclone as well, which provides the check command to compare two directories (or indeed remotes):\n$ rclone check .dud/cache /tmp/dud/cache 2022/07/18 01:32:43 NOTICE: Config file \u0026quot;/home/user/.config/rclone/rclone.conf\u0026quot; not found - using defaults 2022/07/18 01:32:45 NOTICE: Local file system at /tmp/dud/cache: 0 differences found 2022/07/18 01:32:45 NOTICE: Local file system at /tmp/dud/cache: 10 matching files Sure enough, rclone reports that .dud/cache and /tmp/dud/cache are identical. If it were \u0026ldquo;real\u0026rdquo;, our collaborators with access to fake_remote could now access all of the data we\u0026rsquo;ve committed so far! Let\u0026rsquo;s pretend we are one of those collaborators, and we need to fetch the data files from the remote cache. We can do that with the aptly-named fetch command:\n$ rm -rf .dud/cache/* # start with an empty local cache $ dud fetch fetching stage cifar.yaml Transferred: 162.600 MiB / 162.600 MiB, 100%, 0 B/s, ETA - Transferred: 1 / 1, 100% Elapsed time: 0.3s Fixing permissions 1 / 1 fetching stage extract_cifar.yaml Transferred: 974 B / 974 B, 100%, 0 B/s, ETA - Transferred: 1 / 1, 100% Elapsed time: 0.0s Fixing permissions 1 / 1 Transferred: 177.588 MiB / 177.588 MiB, 100%, 0 B/s, ETA - Transferred: 8 / 8, 100% Elapsed time: 0.2s Fixing permissions 8 / 8 $ rclone check .dud/cache /tmp/dud/cache 2022/07/18 01:32:47 NOTICE: Config file \u0026quot;/home/user/.config/rclone/rclone.conf\u0026quot; not found - using defaults 2022/07/18 01:32:48 NOTICE: Local file system at /tmp/dud/cache: 0 differences found 2022/07/18 01:32:48 NOTICE: Local file system at /tmp/dud/cache: 10 matching files dud fetch is the inverse of dud push; it looks up artifacts the same way push does (from stage files), but it copies from the remote cache to the local cache.\nVersioning our code with Git # We\u0026rsquo;ve now stored our data in a shared location and we know how to get it back. Next, we need to do the same with our code. Sharing the code \u0026ndash; our stage files and configuration \u0026ndash; is critical; without them, our collaborators (and ourselves!) won\u0026rsquo;t be able to make sense of the data. Furthermore, we want to version our stage files so we can trace the changes in our pipeline over time. Lucky for us, the practice of versioning and sharing source code is a pillar of the digital world, and there are many source control management (SCM) tools at our disposal that are designed for our situation.\nWe\u0026rsquo;ll use Git to version and share our code. Git is the most popular SCM tool, but in practice you could use any SCM tool for this project (e.g. Mercurial). If you\u0026rsquo;re not familiar with Git, don\u0026rsquo;t worry; we\u0026rsquo;ll only be running the most basic Git operations in this walkthrough. That said, Dud\u0026rsquo;s command-line interface (CLI) is intentionally meant to mirror the core Git commands. If you\u0026rsquo;ve followed along this far, the Git commands below should hopefully look very familiar. (And indeed the inverse is true as well: If you\u0026rsquo;re familiar with Git but new to Dud, the hope is you\u0026rsquo;ll feel right at home with Dud\u0026rsquo;s CLI.)\nThe steps below gloss over installing and configuring Git. If you are new to Git, please search out any of the countless resources on the Web to learn more.\nFirst things first, let\u0026rsquo;s create a Git repository for the project:\n$ git init Initialized empty Git repository in /home/user/cifar/.git/ Let\u0026rsquo;s take a look at our status to decide what to commit:\n$ git status On branch main No commits yet Untracked files: (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed) .dud/ cifar-10-batches-py/ cifar-10-python.tar.gz cifar.yaml extract_cifar.yaml pipeline.png nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to track) We can see that Git is suggesting that we use it to track a bunch of files. We\u0026rsquo;re already tracking the CIFAR tarball and its contents with Dud, so we don\u0026rsquo;t want them tracked in Git. (But remember, we do want to track their Dud stage files in Git! See the discussion directly above.) Also, it\u0026rsquo;s not important to track our picture of the Dud pipeline, pipeline.png. With these things in mind, we\u0026rsquo;ll write a .gitignore file that tells Git to ignore these files:\n# .gitignore /cifar-10-batches-py *.tar.* *.png $ git status On branch main No commits yet Untracked files: (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed) .dud/ .gitignore cifar.yaml extract_cifar.yaml nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to track) That\u0026rsquo;s better. Now, the Git-savvy folks in the audience may be concerned about tracking the entire .dud directory in Git. After all, .dud/cache contains all of our large binary files, and they are not suited for source control. As it turns out, dud init automatically creates its own .gitignore file in the .dud directory to help prevent the painful mistake of committing the Dud cache to source control. (If you use another SCM tool, be careful: You\u0026rsquo;ll need to manually exclude your Dud cache!)\nLet\u0026rsquo;s tell Git to track everything else:\n$ git add . $ git status On branch main No commits yet Changes to be committed: (use \u0026quot;git rm --cached \u0026lt;file\u0026gt;...\u0026quot; to unstage) new file: .dud/.gitignore new file: .dud/config.yaml new file: .dud/index new file: .dud/rclone.conf new file: .gitignore new file: cifar.yaml new file: extract_cifar.yaml With everything in order, let\u0026rsquo;s commit our code:\n$ git commit -m 'initial commit' [main (root-commit) ca689da] initial commit 7 files changed, 25 insertions(+) create mode 100644 .dud/.gitignore create mode 100644 .dud/config.yaml create mode 100644 .dud/index create mode 100644 .dud/rclone.conf create mode 100644 .gitignore create mode 100644 cifar.yaml create mode 100644 extract_cifar.yaml Excellent, our code is committed to our Git repository! The next step would be to create a remote Git repository and push our commit to it. I\u0026rsquo;ll leave this as an exercise for the reader, but once you\u0026rsquo;ve done that, this entire project \u0026ndash; the data and the code \u0026ndash; will be fully published and ready to share with others! You can find good tutorials on how to set up a remote Git repository on any number of Git hosting services, such as GitHub, GitLab, sourcehut, and many more.\nSummary # In this page we walked through the core capabilities of Dud: storing and versioning large files and directories, and creating reproducible data pipelines. We finished by preparing our code and data to be shared with others. If you haven\u0026rsquo;t already, now\u0026rsquo;s a good time to install Dud and give it a go yourself! If you want to learn more, check out the CLI Reference or reach out on Github Discussions.\n"},{"id":2,"href":"/dud/dev/benchmarks/","title":"Benchmarks","section":"","content":" Benchmarks # System Information # OS: Linux 5.18\nCPU: Intel(R) Core(TM) i3-7100 CPU @ 3.90GHz\nRAM: 16 GB\nGo version: 1.18.4\nRclone version: rclone v1.59.0\nDud version: v0.4.0\nDVC version: 2.13.0 (pip)\nDVC non-default configuration:\ncore.analytics=false core.check_update=false cache.type=symlink Few large files # This dataset consists of four 1 GB files in a single directory.\ncheckout # Command Mean [s] Min [s] Max [s] Relative Dud 0.023 ± 0.000 0.022 0.023 1.00 DVC 0.338 ± 0.013 0.326 0.352 14.92 ± 0.64 commit # Command Mean [s] Min [s] Max [s] Relative Dud 0.677 ± 0.030 0.644 0.701 1.00 DVC 6.483 ± 0.012 6.471 6.495 9.57 ± 0.42 fetch # Command Mean [s] Min [s] Max [s] Relative Dud 11.876 ± 1.790 10.703 13.936 1.53 ± 0.43 DVC 7.764 ± 1.813 5.759 9.288 1.00 push # Command Mean [s] Min [s] Max [s] Relative Dud 10.755 ± 0.240 10.538 11.012 1.52 ± 0.30 DVC 7.082 ± 1.393 5.987 8.650 1.00 status # Command Mean [s] Min [s] Max [s] Relative Dud 0.018 ± 0.006 0.011 0.022 1.00 DVC 0.298 ± 0.006 0.291 0.303 16.57 ± 5.21 Many small files # This dataset consists of twenty thousand 100 KB files in a single directory.\ncheckout # Command Mean [s] Min [s] Max [s] Relative Dud 1.262 ± 0.430 1.013 1.759 1.00 DVC 9.021 ± 0.063 8.983 9.093 7.15 ± 2.44 commit # Command Mean [s] Min [s] Max [s] Relative Dud 1.668 ± 0.030 1.636 1.695 1.00 DVC 45.934 ± 5.117 40.035 49.171 27.54 ± 3.11 fetch # Command Mean [s] Min [s] Max [s] Relative Dud 7.605 ± 0.042 7.563 7.647 1.00 DVC 57.540 ± 2.498 56.029 60.422 7.57 ± 0.33 push # Command Mean [s] Min [s] Max [s] Relative Dud 9.896 ± 4.191 7.438 14.735 1.00 DVC 44.301 ± 0.245 44.072 44.558 4.48 ± 1.90 status # Command Mean [s] Min [s] Max [s] Relative Dud 0.283 ± 0.012 0.270 0.295 1.00 DVC 1.575 ± 0.015 1.562 1.592 5.56 ± 0.24 "},{"id":3,"href":"/dud/dev/concepts/","title":"Concepts","section":"","content":" Concepts # Artifact # An Artifact is a file or directory that is tracked by Dud. Artifacts are usually stored in the Cache, but it isn\u0026rsquo;t strictly necessary.\nStage # A Stage is a group of Artifacts, or an operation that consumes and/or produces a group of Artifacts. Stages are defined by the user in YAML files and should be tracked with source control. The Stage YAML file format is described in dud stage --help.\nIndex # The Index is the comprehensive group of Stages in a project. It is stored in a plain text file at .dud/index. The Index forms a dependency graph of Stages, enabling the user to define data pipelines.\nCache # The Cache is a local directory where Dud stores and versions the contents of Artifacts. The Cache is content-addressed, which (among other things) facilitates storing all versions of all Artifacts without conflicts or duplication.\n"},{"id":4,"href":"/dud/dev/cli/dud/","title":"dud","section":"CLI Reference","content":" dud # Synopsis # Dud is a lightweight tool for versioning data alongside source code and building data pipelines.\nOptions # -h, --help help for dud --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud checkout\t- Load committed artifacts from the cache dud checksum\t- Checksum files or bytes from STDIN dud commit\t- Save artifacts to the cache and record their checksums dud completion\t- Generate shell completion script dud config\t- Print or modify fields in the config file dud fetch\t- Fetch committed artifacts from the remote cache dud graph\t- Print the stage graph in graphviz DOT format dud init\t- Initialize a Dud project dud pull\t- Fetch artifacts from the remote and checkout dud push\t- Push committed artifacts to the remote cache dud run\t- Run stages or pipelines dud stage\t- Commands for interacting with stages and the index dud status\t- Print the state of one or more stages dud version\t- Print the version number and exit "},{"id":5,"href":"/dud/dev/cli/dud_checkout/","title":"dud checkout","section":"CLI Reference","content":" dud checkout # Load committed artifacts from the cache\nSynopsis # Checkout loads previously committed artifacts from the cache.\nFor each stage file passed in, checkout makes the stage\u0026rsquo;s output artifacts available in the workspace. By default, checkout creates symlinks to the cache, but copies of the cached artifacts can be checked out using \u0026ndash;copy. If no stage files are passed in, checkout will act on all stages in the index. By default, checkout will act recursively on all stages upstream of the given stage(s).\ndud checkout [flags] [stage_file]... Options # -c, --copy copy artifacts instead of linking -h, --help help for checkout -s, --single-stage disable recursive operation on upstream stages Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":6,"href":"/dud/dev/cli/dud_checksum/","title":"dud checksum","section":"CLI Reference","content":" dud checksum # Checksum files or bytes from STDIN\nSynopsis # Checksum reads files (or bytes from STDIN) and prints their checksums.\nThe CLI is intended to be compatible with the *sum family of command-line tools (although this version is currently incomplete).\ndud checksum [flags] [file]... Options # -b, --bufsize int internal buffer size in bytes -h, --help help for checksum Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":7,"href":"/dud/dev/cli/dud_commit/","title":"dud commit","section":"CLI Reference","content":" dud commit # Save artifacts to the cache and record their checksums\nSynopsis # Commit saves artifacts to the cache and record their checksums.\nFor each stage file passed in, commit saves all output artifacts in the cache and records their checksums in the stage file. If no stage files are passed in, commit will act on all stages in the index. By default, commit will act recursively on all stages upstream of the given stage(s).\ndud commit [flags] [stage_file]... Options # -c, --copy On checkout, copy the file instead of linking. -h, --help help for commit Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":8,"href":"/dud/dev/cli/dud_completion/","title":"dud completion","section":"CLI Reference","content":" dud completion # Generate shell completion script\nSynopsis # Completion generates a completion script for the given shell.\nBash # $ source \u0026lt;(dud completion bash) To load completions for each session, execute once:\nOn Linux:\n$ dud completion bash \u0026gt; /etc/bash_completion.d/dud On MacOS:\n$ dud completion bash \u0026gt; /usr/local/etc/bash_completion.d/dud Zsh # If shell completion is not already enabled in your environment you will need to enable it. You can execute the following once:\n$ echo \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc To load completions for each session, execute once:\n$ dud completion zsh \u0026gt; \u0026quot;${fpath[1]}/_dud\u0026quot; You will need to start a new shell for this setup to take effect.\nFish # $ dud completion fish | source To load completions for each session, execute once:\n$ dud completion fish \u0026gt; ~/.config/fish/completions/dud.fish dud completion {bash|zsh|fish} Options # -h, --help help for completion Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":9,"href":"/dud/dev/cli/dud_config/","title":"dud config","section":"CLI Reference","content":" dud config # Print or modify fields in the config file\nSynopsis # Config prints or modifies fields in the config file\nOptions # -h, --help help for config Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- dud config get\t- Get the value of a field in the config file dud config path\t- Print the config file path dud config set\t- Set the value of a field in the config file "},{"id":10,"href":"/dud/dev/cli/dud_config_get/","title":"dud config get","section":"CLI Reference","content":" dud config get # Get the value of a field in the config file\nSynopsis # Get the value of a field in the config file\ndud config get \u0026lt;config_field\u0026gt; [flags] Options # -h, --help help for get Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud config\t- Print or modify fields in the config file "},{"id":11,"href":"/dud/dev/cli/dud_config_path/","title":"dud config path","section":"CLI Reference","content":" dud config path # Print the config file path\nSynopsis # Print the config file path\ndud config path [flags] Options # -h, --help help for path -u, --user target the user-level config file Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud config\t- Print or modify fields in the config file "},{"id":12,"href":"/dud/dev/cli/dud_config_set/","title":"dud config set","section":"CLI Reference","content":" dud config set # Set the value of a field in the config file\nSynopsis # Set the value of a field in the config file\ndud config set \u0026lt;config_field\u0026gt; \u0026lt;new_value\u0026gt; [flags] Options # -h, --help help for set -u, --user target the user-level config file Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud config\t- Print or modify fields in the config file "},{"id":13,"href":"/dud/dev/cli/dud_fetch/","title":"dud fetch","section":"CLI Reference","content":" dud fetch # Fetch committed artifacts from the remote cache\nSynopsis # Fetch downloads previously committed artifacts from a remote cache.\nFor each stage passed in, fetch downloads the stage\u0026rsquo;s committed outputs from the remote cache specified in the Dud config file. If no stage files are passed in, fetch will act on all stages in the index. By default, fetch will act recursively on all stages upstream of the given stage(s).\nThis command requires rclone to be installed on your machine. Visit https://rclone.org/ for more information and installation instructions.\ndud fetch [flags] [stage_file]... Options # -h, --help help for fetch -s, --single-stage don\u0026#39;t operate recursively over Stage inputs Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":14,"href":"/dud/dev/cli/dud_graph/","title":"dud graph","section":"CLI Reference","content":" dud graph # Print the stage graph in graphviz DOT format\nSynopsis # Graph prints the stage graph in graphviz DOT format.\nFor each stage file passed in, graph will print the graph of the stage and all upstream stages in Graphviz DOT format. If no stage files are passed in, graph will act on all stages in the index.\nYou can pipe the output of this command to \u0026lsquo;dot\u0026rsquo; from the graphviz package to generate images of the stage graph. Visit https://graphviz.org for more information about Graphviz and for installation instructions.\ndud graph [flags] [stage_file]... Examples # dud graph | dot -Tpng -o dud.png Options # -h, --help help for graph --stages-only only show stages; no artifacts Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":15,"href":"/dud/dev/cli/dud_init/","title":"dud init","section":"CLI Reference","content":" dud init # Initialize a Dud project\nSynopsis # Init initializes a Dud project in the current directory.\ndud init [flags] Options # -h, --help help for init Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":16,"href":"/dud/dev/cli/dud_pull/","title":"dud pull","section":"CLI Reference","content":" dud pull # Fetch artifacts from the remote and checkout\nSynopsis # Pull runs fetch followed by checkout.\nThis command requires rclone to be installed on your machine. Visit https://rclone.org/ for more information and installation instructions.\ndud pull [flags] [stage_file]... Options # -c, --copy copy artifacts instead of linking -h, --help help for pull -s, --single-stage don\u0026#39;t operate recursively over Stage inputs Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":17,"href":"/dud/dev/cli/dud_push/","title":"dud push","section":"CLI Reference","content":" dud push # Push committed artifacts to the remote cache\nSynopsis # Push uploads previously committed artifacts to a remote cache.\nFor each stage passed in, push uploads the stage\u0026rsquo;s committed outputs to the remote cache specified in the Dud config file. If no stage files are passed in, push will act on all stages in the index. By default, push will act recursively on all stages upstream of the given stage(s).\nThis command requires rclone to be installed on your machine. Visit https://rclone.org/ for more information and installation instructions.\ndud push [flags] [stage_file]... Options # -h, --help help for push -s, --single-stage disable recursive operation on upstream stages Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":18,"href":"/dud/dev/cli/dud_run/","title":"dud run","section":"CLI Reference","content":" dud run # Run stages or pipelines\nSynopsis # Run runs stages or pipelines.\nFor each stage passed in, run executes a stage\u0026rsquo;s command if it is out-of-date. If no stage files are passed in, run will act on all stages in the index. By default, run will act recursively on all stages upstream of the given stage, and thus run will execute a stage\u0026rsquo;s command if any upstream stages are out-of-date.\ndud run [flags] [stage_file]... Options # -h, --help help for run -s, --single-stage disable recursive operation on upstream stages Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":19,"href":"/dud/dev/cli/dud_stage/","title":"dud stage","section":"CLI Reference","content":" dud stage # Commands for interacting with stages and the index\nSynopsis # Stage is a group of commands for interacting with stages and the index.\nA Stage is a group of Artifacts, or an operation that consumes and/or produces a group of Artifacts. Stages are defined by the user in YAML files and should be tracked with source control.\nBelow is a fully-annotated Stage YAML file for reference.\n# The checksum of this Stage definition, written during \u0026#39;dud commit\u0026#39;. This # checksum is used to determine when a Stage definition has been modified by # a user. The checksum does not include Artifact checksums. checksum: abcdefghijklmnopqrstuvwxyz1234567890 # The shell command to run when \u0026#39;dud run\u0026#39; is called. \u0026#39;/bin/sh\u0026#39; is used to # run the command. (Stage commands are optional.) command: python train.py # The directory in which the Stage\u0026#39;s command is executed. Like all paths in # a Stage definition, it must be a directory path relative to the project\u0026#39;s root # directory. An empty or omitted value means the command is executed in the # project root directory. The working directory only affects the Stage\u0026#39;s command; # all inputs and outputs of the Stage must also have paths relative to the # project root. working-dir: . # The set of Artifacts which the Stage requires to run \u0026#39;command\u0026#39; above. inputs: # The Artifact path. All paths are relative to the project\u0026#39;s root # directory. train.py: # The checksum of the artifact\u0026#39;s contents, written during \u0026#39;dud commit\u0026#39;. checksum: abcdefghijklmnopqrstuvwxyz1234567890 # The set of Artifacts which are owned by the Stage. outputs: # This is how to define a file Artifact with default options. The colon (:) # at the end is still required. You may see \u0026#39;dud stage gen\u0026#39; include empty curly # braces ({}) after the colon; this is equivalent to the below. model.pkl: tensorboard: # \u0026#39;is-dir\u0026#39; tells Dud to expect this Artifact to be a directory, not a file. # Defaults to false when omitted. is-dir: true # \u0026#39;disable-recursion\u0026#39; tells Dud not to recurse directories when operating on # this directory Artifact; all sub-directories will be ignored. Defaults to # false (applies recursion) when omitted. Not applicable for file # Artifacts. disable-recursion: true metrics.json: # \u0026#39;skip-cache\u0026#39; tells Dud not to commit this Artifact to the cache. Dud will # still write a checksum for this Artifact during \u0026#39;dud commit\u0026#39;, and it will # use the checksum to inform other actions, such as \u0026#39;dud run\u0026#39;. This is useful # for declaring Stage outputs which can be safely stored in source control # rather than Dud. This option is implicit for Artifacts in \u0026#39;inputs\u0026#39;. skip-cache: true Options # -h, --help help for stage Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- dud stage add\t- Add one or more stage files to the index dud stage gen\t- Generate stage YAML using the CLI dud stage remove\t- Remove one or more stage files from the index "},{"id":20,"href":"/dud/dev/cli/dud_stage_add/","title":"dud stage add","section":"CLI Reference","content":" dud stage add # Add one or more stage files to the index\nSynopsis # Add adds one or more stage files to the index.\nAdd loads each stage file passed on the command line, validates its contents, checks if it conflicts with any stages already in the index, then adds the stage to the index file.\ndud stage add stage_file... [flags] Options # -h, --help help for add Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud stage\t- Commands for interacting with stages and the index "},{"id":21,"href":"/dud/dev/cli/dud_stage_gen/","title":"dud stage gen","section":"CLI Reference","content":" dud stage gen # Generate stage YAML using the CLI\nSynopsis # Gen generates stage YAML and prints it to standard output.\nThe output of this command can be redirected to a file and modified further as needed.\ndud stage gen [flags] [--] [stage_command]... Examples # dud stage gen -o data/ python download_data.py \u0026gt; download.yaml Options # -h, --help help for gen -i, --in strings one or more input files or directories -o, --out strings one or more output files or directories -w, --work-dir string working directory for the stage\u0026#39;s command Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud stage\t- Commands for interacting with stages and the index "},{"id":22,"href":"/dud/dev/cli/dud_stage_remove/","title":"dud stage remove","section":"CLI Reference","content":" dud stage remove # Remove one or more stage files from the index\nSynopsis # Remove removes one or more stage files from the index.\ndud stage remove stage_file... [flags] Options # -h, --help help for remove Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud stage\t- Commands for interacting with stages and the index "},{"id":23,"href":"/dud/dev/cli/dud_status/","title":"dud status","section":"CLI Reference","content":" dud status # Print the state of one or more stages\nSynopsis # Status prints the state of one or more stages.\nFor each stage file passed in, status will print the current state of the stage. If no stage files are passed in, status will act on all stages in the index. By default, status will act recursively on all stages upstream of the given stage(s).\ndud status [flags] [stage_file]... Options # --debug print verbose JSON instead of regular output -h, --help help for status Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "},{"id":24,"href":"/dud/dev/cli/dud_version/","title":"dud version","section":"CLI Reference","content":" dud version # Print the version number and exit\ndud version [flags] Options # -h, --help help for version Options inherited from parent commands # --profile enable profiling --trace enable tracing -v, --verbose increase output verbosity SEE ALSO # dud\t- "}]